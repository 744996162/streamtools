<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>streamtools</title>
    
    <link rel="stylesheet" type="text/css" href="http://documentup.com/stylesheets/screen.css">
    
    

    

    <!-- Typekit -->
    
      <script type="text/javascript">
        (function() {
          var config = {
            kitId: 'hjp0pft',
            scriptTimeout: 3000
          };
          var h=document.getElementsByTagName("html")[0];h.className+=" wf-loading";var t=setTimeout(function(){h.className=h.className.replace(/( |^)wf-loading( |$)/g,"");h.className+=" wf-inactive"},config.scriptTimeout);var tk=document.createElement("script");tk.src='//use.typekit.net/'+config.kitId+'.js';tk.type="text/javascript";tk.async="true";tk.onload=tk.onreadystatechange=function(){var a=this.readyState;if(a&&a!="complete"&&a!="loaded")return;clearTimeout(t);try{Typekit.load(config)}catch(b){}};var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(tk,s)
        })();
      </script>
    
  </head>
  <body><div id="container">
  <div id="nav">
    
      <div id="header">
        <a href="#" id="logo">streamtools</a>
      </div>
    
    <ul id="sections">
      
        <li>
          <a href="#intro">intro</a>
          
        </li>
      
        <li>
          <a href="#install">install</a>
          
            <ul>
              
                <li>
                  <a href="#install/binary">binary</a>
                </li>
              
                <li>
                  <a href="#install/source">source</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#getting-started">getting started</a>
          
        </li>
      
        <li>
          <a href="#how-it-works">how it works</a>
          
        </li>
      
        <li>
          <a href="#reference">reference</a>
          
            <ul>
              
                <li>
                  <a href="#reference/blocks">blocks</a>
                </li>
              
                <li>
                  <a href="#reference/interface">interface</a>
                </li>
              
                <li>
                  <a href="#reference/api">api</a>
                </li>
              
                <li>
                  <a href="#reference/blocks">blocks</a>
                </li>
              
                <li>
                  <a href="#reference/command-line">command line</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#more-info">More Info</a>
          
        </li>
      
    </ul>
    
    
  </div>
  <div id="content">
    
    <h2 id='intro'>intro</h2 id='intro'>
<p>Streamtools is a graphical toolkit for dealing with streams of data. Streamtools makes it easy to explore, analyse, modify and learn from streams of data.</p>
<p>You&#39;ll primarily interact with streamtools in the browser. However, since all functionality is exposed over HTTP, you can use tools like curl to send commands and even treat any part of streamtools as an API endpoint. More about that later.</p>
<h2 id='install'>install</h2 id='install'>
<h3 id='install/binary'>binary</h3 id='install/binary'>
<p>Download the appropriate version of the latest streamtools for your operating system from our <a href="https://github.com/nytlabs/streamtools/releases/tag/">releases on github</a>.</p>
<p>Extract the archive (it&#39;ll either be a .tar.gz or .zip)</p>
<p>Navigate to the extracted folder and run the <code>st</code> executable.</p>
<ul>
<li>from Terminal: <code>./st</code></li>
<li>from Finder: double click</li>
</ul>
<p>You should see streamtools start up, telling you it&#39;s running on port 7070.</p>
<p>Now, open a browser window and point it at <a href="http://localhost:7070/">localhost:7070</a>. You should see a (nearly) blank page. At the bottom you should see a status bar that says <code>client: connected to Streamtools</code> followed by a version number. Congratulations! You&#39;re in.</p>
<h3 id='install/source'>source</h3 id='install/source'>
<p>Make sure you have go, git, hg, and bzr installed. You can download go for <a href="http://golang.org/doc/install#osx">Mac OS X</a>, <a href="http://golang.org/doc/install#tarball">Linux and FreeBSD</a> and <a href="http://golang.org/doc/install#windows">Windows</a> from the <a href="http://golang.org/">golang.org</a> website. Git, hg and bzr are simple enough to install using homebrew, apt or your OS package manager of choice.</p>
<p>Once you have these dependencies, compile streamtools with these commands:</p>
<pre><code>mkdir -p ~<span class="regexp">/go/src</span><span class="regexp">/github.com/nytlabs</span>
cd ~<span class="regexp">/go/src</span><span class="regexp">/github.com/nytlabs</span>
git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>nytlabs/streamtools.git
cd streamtools
make</code></pre>
<p>To start the streamtools server:</p>
<pre><code><span class="variable">$ </span>.<span class="regexp">/build/st</span>
<span class="constant">Apr</span> <span class="number">30</span> <span class="number">19</span><span class="symbol">:</span><span class="number">44</span><span class="symbol">:</span><span class="number">36</span> [ <span class="constant">SERVER</span> ][ <span class="constant">INFO</span> ] <span class="string">"Starting Streamtools 0.2.5 on port 7070"</span></code></pre>
<p>You should see a message similar to the one above letting you know streamtools is running at port 7070.</p>
<h2 id='getting-started'>getting started</h2 id='getting-started'>
<p>Streamtools is a binary that can run on your local machine or a remote server. We usually run it using upstart on an ubuntu ec2 server in Amazon&#39;s cloud. To begin with, though, we&#39;ll assume that you&#39;re running streamtools locally, on a machine you can touch. We&#39;re also going to assume you&#39;re running OSX or Linux - if you&#39;re a Windows user we do provide binaries but don&#39;t know much about how to interact with a Windows machine - you will need to translate these instructions to Windows yourself.</p>
<p>Before we go any further, you should make sure you&#39;ve installed streamtools. Check out the directions on starting the server, either from a binary release or from source, if you haven&#39;t already done so.</p>
<p>You should see streamtools start up, telling you it&#39;s running on port 7070.</p>
<p>Now, open a browser window and point it at <a href="http://localhost:7070/">localhost:7070</a>. You should see a (nearly) blank page. At the bottom you should see a status bar that says <code>client: connected to Streamtools</code> followed by a version number. Congratulations! You&#39;re in.</p>
<p>As a &quot;Hello World&quot;, try double-clicking anywhere on the page above the status bar, type <code>fromhttpstream</code> and hit enter. This will bring up your first block. Double-click on the block and enter <code>http://developer.usa.gov/1usagov</code> in the <code>Endpoint</code> text-box. Hit the update button. Now double-click on the page and make a <code>tolog</code> block. Finally, connect the two blocks together by first clicking on the <code>fromhttpstream</code> block&#39;s OUT route (a litle black square on the bottom of the block) to the <code>tolog</code> block&#39;s IN route (which is the little black square on the top of the block). Click on the status bar and, after a moment, you should start to see JSON scroll through the log - these are live clicks on the US government short links! Click anywhere on the log to make it go away again.</p>
<h2 id='how-it-works'>how it works</h2 id='how-it-works'>
<p>Streamtools&#39; basic paradigm is straightforward: data flows from <em>blocks</em> through <em>connections</em> to other blocks.</p>
<ul>
<li>A block perfoms some operation on each message it recieves, and that operation is defined by the block&#39;s <em>type</em>.</li>
<li>Each block has zero or more <em>rules</em> which define that block&#39;s behaviour.</li>
<li>Each block has a set of named <em>routes</em> that can recieve data, emit data, or respond to queries.</li>
<li>You can connect blocks together, via their routes, using connections. You can connect to any inbound route, and so data flowing through streamtools can be used to set the rules of the blocks in the running pattern.</li>
<li>We call a collection of connected blocks a <em>pattern</em>, and it is possible to export and import whole patterns from a running instance of streamtools.</li>
</ul>
<p>Together, these 5 concepts: blocks, rules, connections, routes and patterns form the basic vocabulary we use to talk about streamtools, and about streaming data systems.</p>
<h2 id='reference'>reference</h2 id='reference'>
<h3 id='reference/blocks'>blocks</h3 id='reference/blocks'>
<p>Each block is briefly detailed below, along with the rules that define each block. To make a block in streamtools, double click anywhere on the page and type the name of the block as they appear below. For programmatic access, see the [[API]] docs.</p>
<p>Blocks rely on some general concepts:
* <em>gojee path</em>: The path rules all use <a href="https://github.com/nytlabs/gojee">gojee</a> syntax to specify which value you&#39;d like to use in the block. Paths always start with the period, which indicates the top-level of the message. So if you want to refer to the whole message use <code>.</code>. If you want to refer to a specific value then they follow the first period. So if you have a message that looks like</p>
<pre><code>    {
        "<span class="attribute">user</span>":<span class="value">{
            "<span class="attribute">username</span>":<span class="value"><span class="string">"bob_the_user"</span>
            <span class="string">"id"</span>: <span class="number">1234</span>
        }</span>
    }</span></code></pre>
<p>and you&#39;d like to refer to the username then the gojee path would be <code>.user.username</code>.</p>
<ul>
<li><em>gojee expression</em>: <a href="https://github.com/nytlabs/gojee">gojee</a> also allows for expressions. So we can write expressions like <code>.user.id &gt; 1230</code>, which are especially useful in the filter and map blocks.  </li>
<li><em>duration string</em>: We use Go&#39;s duration strings to specify time periods. They are a number followed by a unit and are pretty intuitive. So <code>10ms</code> is 10 milliseconds; <code>5h</code> is 5 hours and so on.</li>
<li><em>route</em>: every block has a set of routes. Routes can either be inbound, query, or outbound routes. Inbound routes receive data from somewhere and send it to the block. Query routes are two-way: they accept an inbound query and return information back to the requester. Outbound routes send data from a block to a connection.</li>
</ul>
<h4>generator blocks</h4>
<p>These blocks emit messages on their own.</p>
<ul>
<li><strong>ticker</strong>. This block emits the time regularly. The time between emissions is specified by the <code>Interval</code>.<ul>
<li>Rules:<ul>
<li><code>Interval</code>: duration string (<code>1s</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>flow blocks</h4>
<p>These blocks are useful for shaping (transforming or manipulating) the stream in one way or another.</p>
<ul>
<li><p><strong>javascript</strong> This block creates a Javascript VM and runs a bit of Javascript once per message. In order to get data in and out of Javascript, the block creates a global variable specified by <code>MessageIn</code> that contains the incoming message. Once the script is finished executing, the block takes the value from the global variable specified by <code>MessageOut</code>.</p>
<ul>
<li>Rules:<ul>
<li><code>MessageIn</code>: string (<code>input</code>)</li>
<li><code>MessageOut</code>: string (<code>output</code>)</li>
<li><code>Script</code>: Javascript (<code>output = input</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>join</strong>. This block joins two streams together. It waits until it has seen a message on both its inputs, then emits the joined message.</p>
</li>
<li><p><strong>map</strong>. This block maps inbound data onto outbound data. The <code>Map</code> rule needs to be valid JSON, where each key is a string and each value is a valid <a href="https://github.com/nytlabs/gojee">gojee</a> expression.</p>
<ul>
<li>Rules:<ul>
<li><code>Map</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> expression</li>
<li><code>Additive</code>: (<code>True</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>mask</strong>. This block allows you to select a subset of the inbound message. To create a mask, you need to build up an empty JSON that looks like the message you&#39;d like out. So, for example, if your in bound message looks like</p>
<pre><code>  {
    "<span class="attribute">A</span>":<span class="value"><span class="string">"foo"</span></span>,
    "<span class="attribute">B</span>":<span class="value"><span class="string">"bar"</span>
  }</span></code></pre>
<p>  and you just want <code>B</code> to come out of the mask block then make the <code>Mask</code> rule:</p>
<pre><code>  {
    "<span class="attribute">B</span>":<span class="value">{}
  }</span></code></pre>
<p>  You can supply any valid JSON to the Mask block. If you specify an empty JSON <code>{}</code> then all values will pass.</p>
<ul>
<li>Rules:<ul>
<li><code>Mask</code>: mask JSON</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>filter</strong>. The filter block applies the provided rule to incoming messages. If the rule evaluates to <code>true</code> then the messages is emitted. If the rule evaluates to <code>false</code> the messages is discarded. The <code>Filter</code> rule can be any valid <a href="https://github.com/nytlabs/gojee">gojee</a> expression. So, for example, if the inbound message looks like</p>
<pre><code>  {
      "<span class="attribute">temperature</span>": <span class="value"><span class="number">43</span>
  }</span></code></pre>
<p>  and you only want to emit messages when the <code>temperature</code> value is above 50, then the filter rule would be</p>
<pre><code>  <span class="string">.</span><span class="comment">temperature</span> &gt; <span class="comment">50</code></pre>
<ul>
<li>Rules:<ul>
<li><code>Filter</code>:<a href="https://github.com/nytlabs/gojee">gojee</a> expression (<code>. != null</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>pack</strong>. The pack block groups blocks together based on a common value. This is almost like an online &quot;group-by&quot; operation, but care needs to be taken in the stream setting as we have to decide when to emit the &quot;packed&quot; message. Imagine you have messages like</p>
<pre><code>  {
       "<span class="attribute">option</span>": <span class="value"><span class="string">"a"</span>
  }</span></code></pre>
<p>  where <code>option</code> can be <code>a</code>, <code>b</code> or <code>c</code>. We would like to make a stream that packs together all the <code>a</code>s together into a single message, and similarly for the <code>b</code>s and <code>c</code>s. We only emit the packed message for a particular value of <code>option</code> when we haven&#39;t seen any messages with that value for 20 seconds, at which point we emit the bunch all at once. Here we would specify <code>20s</code> for the <code>EmitAfter</code> rule  and <code>.option</code> as the <code>Path</code> rule. If we saw three <code>a</code> messages in that 20s the output of the pack block looks like</p>
<pre><code>  {
       "<span class="attribute">pack</span>":<span class="value">[{"<span class="attribute">option</span>": <span class="value"><span class="string">"a"</span>}</span>,{"<span class="attribute">option</span>": <span class="value"><span class="string">"a"</span>}</span>,{"<span class="attribute">option</span>": <span class="value"><span class="string">"a"</span>}</span>]
  }</span></code></pre>
<p>   Our main use case for this at the NYT is to create per-reader reading sessions. So we set the <code>Path</code> to our user-id and we emit after 20 minutes of not hearing anything from that reader&#39;s user-id. Every page-view our readers generate get packed into a per-reader message, generating a stream of reading sessions.</p>
<ul>
<li>Rules:<ul>
<li><code>EmitAfter</code>: duration string</li>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path</li>
</ul>
</li>
</ul>
</li>
<li><strong>unpack</strong>. The unpack block takes an array of objects and emits each object as a separate message. See the <a href="https://github.com/nytlabs/streamtools/blob/master/examples/citibike.json#L77">citibike example</a>, where we unpack a big array of citibike stations into individual messages we can filter.  <ul>
<li>Rules:<ul>
<li><code>Path</code>:<a href="https://github.com/nytlabs/gojee">gojee</a> path</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>sync</strong>. The sync block takes an disordered stream and creates a properly timed, ordered stream at the expense of introducing a lag. To explain this block imagine you have a stream that looks like</p>
<pre><code>  {<span class="string">"val"</span>:<span class="string">"a"</span>, <span class="string">"time"</span>:<span class="number">23</span> } <span class="keyword">...</span> {<span class="string">"val"</span>:<span class="string">"b"</span>, <span class="string">"time"</span>:<span class="number">14</span>} <span class="keyword">...</span> {<span class="string">"val"</span>:<span class="string">"c"</span>, <span class="string">"time"</span>:<span class="number">10</span>}</code></pre>
<p>  Ideally you&#39;d like the stream to be ordered by the timestamp in the message, so the <code>c</code> message comes first, the <code>b</code> message comes second and the <code>a</code> message comes third. In addition, you&#39;d like the time between the messages to respect the timestamp inside the message.</p>
<p>  The sync block achieves this by storing the stream for a fixed amount time (the <code>Lag</code>) and then emitting at the time inside the inbound messages plus the lag. This means we have to wait for a while to get our messages but when we do get them, they&#39;re in a stream whose dynamics reflect the timestamp inside the message.</p>
<p>  This can be very helpful if the plumbing between your sensor and streamtools introduces dynamics that would confuse your analysis. For example, it&#39;s quite common for a system to wait until it has a collection of messages from its sensor before it makes an HTTP request to post those messages to the next stage. This means that by the time those messages make it to a streamtools pattern, they&#39;re artifcially grouped together into little pulses. You can use the sync block to recover the original stream generated by the sensor.</p>
<ul>
<li>Rules:<ul>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path. This must point at a UNIX epoch time in milliseconds,</li>
<li><code>Lag</code>: duration string</li>
</ul>
</li>
</ul>
</li>
<li><strong>gethttp</strong>. The getHTTP block makes an HTTP GET request to a URL you specify in the inbound message. It is necessary for the HTTP endpoint to serve JSON. This block forms the backbone for any sort of polling pattern.<ul>
<li>Rules:<ul>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path to a fully formed URL.</li>
</ul>
</li>
</ul>
</li>
<li><strong>kullbackleibler</strong>. Calculates the <a href="http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">Kullback Leibler divergence</a> between two distributions p and q. The two distributions must mimic the output from the <strong>histogram</strong> block.<ul>
<li>Rules:<ul>
<li><code>QPath</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path to the q distribution.</li>
<li><code>PPath</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path to the p distribution.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>source blocks</h4>
<p>These blocks hook into another system and collect messages to be emitted into streamtools.</p>
<ul>
<li><strong>fromhttpstream</strong>. This block allows you to listen to a long-lived http stream. Each new JSON that appears on the stream is emitted into streamtools. Try using the 1.usa.gov endpoint, available at <code>http://developer.usa.gov/1usagov</code>.<ul>
<li>Rules:<ul>
<li><code>Endpoint</code>: endpoint string</li>
<li><code>Auth</code>: authorisation string</li>
</ul>
</li>
</ul>
</li>
<li><strong>fromnsq</strong>. This block implements an NSQ reader. For more details on how to specify the rule for this block check out the <a href="http://bitly.github.io/nsq/">NSQ docs</a>.<ul>
<li>Rules:<ul>
<li><code>ReadTopic</code>: topic to read from.</li>
<li><code>LookupdAddr</code>: nsqlookupd addresss</li>
<li><code>ReadChannel</code>: name of the channel</li>
<li><code>MaxInFlight</code>: how many messages to take from the queue at a time. (<code>0</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>frompost</strong>. This block emits any message that is POSTed to its IN route. This block isn&#39;t strictly needed as you can POST JSON to any inbound route on any block. Having said that, sometimes it&#39;s a bit clearer to have a dedicated block that listens for data.</li>
<li><strong>fromsqs</strong>. This block connects to an <a href="http://aws.amazon.com/sqs/">Amazon Simple Queueing System</a> queue. Messages from SQS are XML; this block extracts the message string from this XML, which it assumes is newline separated JSON. Each JSON is emitted into streamtools as a separate message. See the SQS docs for more information about the rules of this block.<ul>
<li>Rules:<ul>
<li><code>SignatureVersion</code>: the version number of the signature hash Amazon is expecting for this queue (<code>4</code>)</li>
<li><code>AccessKey</code>: your access key</li>
<li><code>MaxNumberOfMessages</code>: how many messages to pull off the queue at a time (<code>10</code>)</li>
<li><code>APIVersion</code>: what version of the API are you using (<code>2012-11-05</code>)</li>
<li><code>SQSEndpoint</code>: the endpoint (ARM) of the SQS queue you are reading</li>
<li><code>WaitTimeSeconds</code>: how long to wait between polling (<code>0</code>)</li>
<li><code>AccessSecret</code>: your access secret</li>
</ul>
</li>
</ul>
</li>
<li><strong>fromudp</strong>. Listens for messages sent over UDP. Each message is emitted into streamtools.<ul>
<li>Rules:<ul>
<li><code>ConnectionString</code>:</li>
</ul>
</li>
</ul>
</li>
<li><strong>fromwebsocket</strong>. Connects to an existing websocket. Each message it hears from the websocket is emitted into streamtools.<ul>
<li>Rules:<ul>
<li><code>url</code>: address of the websocket.</li>
</ul>
</li>
</ul>
</li>
<li><strong>fromemail</strong>. This block connects to the given IMAP server with the given credentials. Once connected, it idles on that connection and emits any unread emails into streamtools. Once messages have been pulled, the block marks them as read. All email messages will contain the <code>from</code>, <code>to</code>, <code>subject</code>, <code>internal_date</code> and <code>body</code> fields.<ul>
<li>Rules:<ul>
<li><code>Host</code>: hostname of the IMAP server. Defaults to Gmail (imap.gmail.com)</li>
<li><code>Username</code>: user for the email account.</li>
<li><code>Password</code>: password for the email account.</li>
<li><code>Mailbox</code>: the mailbox to pull email from. Defaults to &#39;INBOX&#39; which is the main mailbox for Gmail.</li>
</ul>
</li>
</ul>
</li>
<li><strong>fromHTTPGetRequest</strong>. This block, when a GET request is made to the block&#39;s QUERY endpoint, emits that request into streamtools. The request can be handled by the <strong>toHTTPGetRequest</strong> block.</li>
<li><strong>toHTTPGetRequest</strong>. This block, while deceptively simple, allows the creation of an API that can use streamtools as a backend. The request, should it ever be marshalled into JSON, is represented as <code>{&quot;channel&quot;:&quot;1&quot;}</code> which indicates that the request is a channel with capacity 1.</li>
</ul>
<h4>sink blocks</h4>
<p>These blocks send data to external systems.</p>
<ul>
<li><strong>toelasticsearch</strong>. Send JSON to an <a href="http://www.elasticsearch.org/">elasticsearch</a> instance.<ul>
<li>Rules:<ul>
<li><code>Index</code>:</li>
<li><code>Host</code>:</li>
<li><code>IndexType</code>:</li>
<li><code>Port</code>:</li>
</ul>
</li>
</ul>
</li>
<li><strong>tofile</strong>. Writes a message as JSON to a file. Each message becomes a new line of JSON.<ul>
<li>Rules:<ul>
<li><code>Filename</code>: file to write to</li>
</ul>
</li>
</ul>
</li>
<li><strong>tolog</strong>. Send messages to the log. This is a quick way to look at the data in your stream.</li>
<li><strong>tonsq</strong>. Send messages to an existing <a href="http://bitly.github.io/nsq/">NSQ</a> system.<ul>
<li>Rules:<ul>
<li><code>Topic</code>: topic you will write to</li>
<li><code>NsqdTCPAddrs</code>: address of the NSQ daemon.</li>
</ul>
</li>
</ul>
</li>
<li><strong>tobeanstalkd</strong>. Send jobs to an existing <a href="https://github.com/kr/beanstalkd/">beanstalkd</a> server.<ul>
<li>Rules:<ul>
<li><code>Host</code>: the Host and port of the beanstalkd server e.g. 127.0.0.1:11300</li>
<li><code>TTR</code>: Time to Run. is an integer number of seconds to allow a worker to run this job. This time is counted from the moment a worker reserves a job. If the worker does not delete, release, or bury the job within <TTR> seconds, the job will time out and the server will release the job.</li>
<li><code>Tube</code> : beanstalkd tube to send jobs to. if left blank, jobs are sent to the default tube.</li>
</ul>
</li>
</ul>
</li>
<li><strong>toMongoDB</strong>. Saves messages to a <a href="https://www.mongodb.org/">MongoDB</a> instance or a cluster. The messages can be saved as they come or in bulk depending on the user&#39;s needs.<ul>
<li>Rules:<ul>
<li><code>Host</code>: The host string for the an instance e.g. <code>localhost:27107</code> or a replicaset or a cluster e.g. <code>mongohost1.example.com:27017,mongohost2.example.com:27017,mongoarbiter1.example.com</code></li>
<li><code>Database</code>: Database to which the documents should be written to.</li>
<li><code>Collection</code> : Collection to which the documents should be written to under the specified database.</li>
<li><code>BatchSize</code>: the number of documents to be written together at any time in bulk. if value is set to &lt;= 1, the documents will be written one at a time.</li>
</ul>
</li>
</ul>
</li>
<li><strong>tonsqmulti</strong>. Send messages to an NSQ system in batches. This is useful if you have a fast (&gt;1KHz) stream of data you need to send to NSQ. This block gathers messages for <code>Interval</code> time and then sends. It emits immediately if the block gets more than <code>MaxBatch</code> messages.<ul>
<li>Rules:<ul>
<li><code>Topic</code>: topic you will write to</li>
<li><code>Interval</code>: duration string (<code>1s</code>)</li>
<li><code>NsqdTCPAddrs</code>: address of the NSQ daemon.</li>
<li><code>MaxBatch</code>: size of largest batch (<code>100</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>toemail</strong>. Send messages to an email account. Useful if you want to send out an alert after some kind of event.<ul>
<li>Rules:<ul>
<li><code>Host</code>: hostname of the SMTP server. Defaults to <code>smtp.gmail.com</code> for Gmail.</li>
<li><code>Port</code>: port number for connection to SMTP server. Defaults to <code>587</code> for Gmail.</li>
<li><code>Username</code>: user name of the email account.</li>
<li><code>Password</code>: password of the email account.</li>
<li><code>toPath</code>: the path of the email&#39;s <code>to</code> field within the received message.</li>
<li><code>fromPath</code>: the path of the email&#39;s <code>from</code> field within the received message.</li>
<li><code>subjectPath</code>: the path of the email&#39;s <code>subject</code> field within the received message.</li>
<li><code>bodyPath</code>: the path of the email&#39;s <code>body</code> within the received message.</li>
</ul>
</li>
</ul>
</li>
<li><strong>toHTTPGetRequest</strong>. This block responds to an HTTP GET request that has been generated by <strong>fromHTTPGetRequest</strong>. The inbound message needs to contain both the original request and the message you want to respond with.<ul>
<li>Rules:<ul>
<li><code>RespPath</code>: path to the HTTP request.</li>
<li><code>MsgPath</code>: path to the message you want to respond with on the HTTP request.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>state blocks</h4>
<p>These blocks maintain a state, storing something about the stream of data.</p>
<ul>
<li><strong>histogram</strong>. Build a non-staionary histogram of the inbound messages. Currently this only works with discrete values.<ul>
<li>Rules:<ul>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path to the value over which you&#39;d like to build a histogram.</li>
<li><code>Window</code>: duration string specifying how long to retain messages in the histogram (<code>0</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>count</strong>. This block counts the number of messages it has seen over the specified <code>Window</code>.<ul>
<li>Rules:<ul>
<li><code>Window</code>: duration string (<code>0</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>timeseries</strong>. This block stores an array of the value specified by <code>Path</code> along with the timestamp at the time the message arrived.<ul>
<li>Rules:<ul>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path</li>
<li><code>NumSamples</code>: how many samples to store (<code>0</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>set</strong>. This stores a <a href="http://en.wikipedia.org/wiki/Set_(mathematics">set</a>) of values as specified by the block&#39;s <code>Path</code>. Add new members through the (idempotent) ADD route. If you send a message through the ISMEMBER route, the block will emit true or false. You can also query the cardinality of the set.<ul>
<li>Rules:<ul>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path</li>
</ul>
</li>
</ul>
</li>
<li><strong>movingaverage</strong>. Performs a <a href="http://en.wikipedia.org/wiki/Moving_average">moving average</a> of the values specified by the <code>Path</code> over the duration of the <code>Window</code>.<ul>
<li>Rules:<ul>
<li><code>Path</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path</li>
<li><code>Window</code>: duration string</li>
</ul>
</li>
</ul>
</li>
<li><strong>cache</strong>. Stores string values against keys. Send a key to the <code>lookup</code> route and the value against that key will be emitted.<ul>
<li>Rules:<ul>
<li><code>KeyPath</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path to the element of the inbound message to use as key</li>
<li><code>ValuePath</code>: <a href="https://github.com/nytlabs/gojee">gojee</a> path to the element to store in the cache</li>
</ul>
</li>
</ul>
</li>
<li><strong>queue</strong>. This block represents a FIFO queue. You can push new messages onto the queue via the PUSH in route. You can pop messages off the queue either by hitting the POP inbound route, causing the block to emit the next message on its OUT route, or you can make a GET request to the POP query route and the block will respond with the next message. You can also peek at the next message using the PEEK query route.</li>
</ul>
<h4>random number blocks</h4>
<p>These blocks emit random numbers when polled. So to generate a stream of random numbers, connect a generator block (like a ticker) to a random number block&#39;s POLL endpoint. Each of these blocks emits JSON of the form:</p>
<pre><code>{
    "<span class="attribute">sample</span>": <span class="value"><span class="number">1234</span>
}</span></code></pre>
<ul>
<li><strong>zipf</strong>. This block draws a random number from a <a href="http://en.wikipedia.org/wiki/Zipf%E2%80%93Mandelbrot_law">Zipf-Mandelbrot</a> distribution when polled.<ul>
<li>Rules:<ul>
<li><code>s</code>: (<code>2</code>)</li>
<li><code>v</code>: (<code>5</code>)</li>
<li><code>N</code>: (<code>99</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>gaussian</strong>. This block draws a random number from the <a href="http://en.wikipedia.org/wiki/Gaussian_distribution">Gaussian</a> distribution when polled.<ul>
<li>Rules:<ul>
<li><code>StdDev</code>: (<code>1</code>)</li>
<li><code>Mean</code>: (<code>0</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>poisson</strong>. This block draws a random number from a <a href="http://en.wikipedia.org/wiki/Poisson_distribution">Poisson</a> distribution when polled.<ul>
<li>Rules:<ul>
<li><code>Rate</code>: (<code>1</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>categorical</strong>. This block draws a random number from a <a href="http://en.wikipedia.org/wiki/Categorical_distribution">Categorical</a> distribution when polled.<ul>
<li>Rules:<ul>
<li><code>Weights</code>: (<code>[1]</code>) - a list of weighting parameters. The number drawn from this distribution corresponds to the index of this list. These weights are automatically normalised to sum to one.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id='reference/interface'>interface</h3 id='reference/interface'>
<p>Streamtool&#39;s GUI aims to be responsive and informative, meaning that you can both create and interrogate a live streaming system. At the same time, it aims to be as minimal as possible - the GUI posses a very tight relationship with the underlying streamtools architecture enabling users of streamtools to see and understand the execution of the system.</p>
<h4>make a block</h4>
<p>To make a block, double click anywhere on the background. Type the name of the block you&#39;d like and press enter.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2443728/161a3708-ae3e-11e3-9ac7-7e3062720bd7.gif" alt="create"></p>
<h4>connect two blocks</h4>
<p>To connect two blocks together, first click on an outbound route on the <em>bottom</em> of the block you want to connect from. Almost always this route will be labelled <code>OUT</code> when you mouse over it. Then click on an inbound route on the <em>top</em> of another block. There can be a few inbound routes; common ones are <code>IN</code>, <code>RULE</code>, and <code>POLL</code>. This will create a connection between the blocks.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2443787/8070125c-ae3f-11e3-92ba-8a69f3ef24dc.gif" alt="connect_2"></p>
<h4>set the rule of a block</h4>
<p>To set a block&#39;s rules, double click it. This will open a window where you can enter rules. When you&#39;re done entering rules, hit the update button.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2443884/f2fa3e62-ae42-11e3-8b25-486e8f034677.gif" alt="update_rule"></p>
<h4>query a block</h4>
<p>You can query a block&#39;s rules, or any other queryable route a block has, by clicking on the red squares on the right of the block. These will open a window that shows a JSON representation of that information. An example of a queryable route is <code>COUNT</code> for the count block. If you click on the little red square associated with the <code>COUNT</code> route, then you&#39;ll get a JSON representation of that block&#39;s current count.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2444136/d4178984-ae4a-11e3-8861-869e6dd472b3.gif" alt="query"></p>
<h4>delete a block</h4>
<p>To delete a block you don&#39;t like anymore, click on it and press the delete (backspace) button on your keyboard.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2444176/d2a457ca-ae4b-11e3-81a0-beb016f58bb6.gif" alt="delete"></p>
<h4>move a block</h4>
<p>To move a block around, simply drag it about the place.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2443683/7d8d0cbe-ae3c-11e3-91ad-852e830dbeb8.gif" alt="drag_2"></p>
<h4>see the last message that passed through a connection</h4>
<p>To see the last message that passed through a connection, click and drag the connection&#39;s rate estiamte. This creates a window containing the JSON representation of the last message to pass through that connection.</p>
<p><img src="https://f.cloud.github.com/assets/597897/2443597/b1c2411e-ae39-11e3-9fb4-429e39548620.gif" alt="last_message"></p>
<h3 id='reference/api'>api</h3 id='reference/api'>
<p>Streamtools provides a full RESTful HTTP API allowing the developer to programatically control all aspects of streamtools. The API can be broken up into three parts: those endpoints that general aspects of streamtools, those that control blocks and those that control connections.</p>
<p>If you are running streamtools locally, using the default port, all of the GET endpoints can be queried either by visiting in a browser:</p>
<pre><code><span class="method">http:</span>//<span class="method">localhost:</span><span class="number">7070</span>/{endpoint}</code></pre>
<p>For example, if you wanted to see the streamtools library, visit <code>http://localhost:7070/library</code>.</p>
<p>The POST endpoints are expecting you to send data. To use these you&#39;ll need to use the command line and a program called <code>curl</code>. For example, to create a new <code>tofile</code> block you need to send along the JSON definition of the block, like this:</p>
<pre><code><span class="title">curl</span> <span class="url">http://localhost:7070/blocks</span> -d<span class="string">'{"Type":"tofile","Rule":{"Filename":"test.json"}}'</span></code></pre>
<p>This POSTs the JSON <code>{&quot;Type&quot;:&quot;tofile&quot;,&quot;Rule&quot;:{&quot;Filename&quot;:&quot;test.json&quot;}}</code> to the <code>/blocks</code> endpoint.</p>
<h4>streamtools</h4>
<p>GET <code>/library</code></p>
<p>The library endpoint returns a description of all the blocks available in the version of streamtools that is runnning.</p>
<p>GET <code>/version</code></p>
<p>The version endpoint returns the current version of streamtools.</p>
<p>GET <code>/export</code></p>
<p>Export returns a JSON representation of the current streamtools pattern.</p>
<p>POST <code>/import</code></p>
<p>Import accepts a JSON representation of a pattern, creating it in the running streamtools instance. Any block ID collissions are resolved automatically, meaning you can repeatedly import the same pattern if it&#39;s useful.</p>
<h4>data</h4>
<p>Every block that as an <code>OUT</code> route also has a websocket and a long-lived HTTP connection associated with it. These are super useful for getting data out of streamtools.</p>
<p>WEBSOCKET <code>/ws/{id}</code></p>
<p>a websocket emitting every message sent on the block&#39;s <code>OUT</code> route.</p>
<p>GET <code>/stream/{id}</code></p>
<p>a long-lived HTTP stream of every message sent on the block&#39;s <code>OUT</code> route.</p>
<h3 id='reference/blocks'>blocks</h3 id='reference/blocks'>
<p>A block&#39;s JSON representation uses the following schema:</p>
<pre><code>{
  <span class="string">"Id"</span>:
  <span class="string">"Type"</span>:
  <span class="string">"Rule"</span>:{ <span class="keyword">...</span> }
  <span class="string">"Position"</span>:{
    <span class="string">"X"</span>:
    <span class="string">"Y"</span>:
  }
}</code></pre>
<p>Only <code>Type</code> is required, everything will be automatically generated if you don&#39;t specify them. The <code>Id</code> is used to uniquely identify that block within streamtools. This is normally just a number but can be any string. <code>Type</code> is the type of the block, selected from the streamtools library. <code>Rule</code> specifies the block&#39;s rule, which will be different for each block. Finally <code>Position</code> specifies the x and y coordinates of the block from the top left corner of the screen.</p>
<p>POST <code>/blocks</code></p>
<p>To create a new block, simply POST its JSON representation as described above to the <code>/blocks</code> endpoint.</p>
<p>GET <code>/blocks/{id}</code></p>
<p>Returns a JSON representation of the block specified by <code>{id}</code>.</p>
<p>DELETE <code>/blocks/{id}</code></p>
<p>Deletes the block specified by <code>{id}</code>.</p>
<p>POST <code>/blocks/{id}/{route}</code></p>
<p>Send data to a block. Each block has a set of default routes (&quot;in&quot;,&quot;rule&quot;) and optional routes (&quot;poll&quot;), as well as custom rotues that defined by the block designer as they see fit. This will POST your JSON to the block specified by <code>{id}</code> via route <code>{route}</code>.</p>
<p>GET <code>/blocks/{id}/{route}</code></p>
<p>Recieve data from a block. Use this endpoint to query block routes that return data. The only default route is <code>rule</code> which, in response to a GET query, will return the block&#39;s current rule.</p>
<h4>connections</h4>
<p>A connection&#39;s JSON representation uses the following schema:</p>
<pre><code><span class="rules">{
  <span class="rule"><span class="attribute">Id</span>:<span class="value">
  FromId:
  ToId:
  ToRoute:
}</span></span></span></code></pre>
<p>Here, only <code>Id</code> is optional. <code>Id</code> is used to uniquely refer to the connection inside streamtools. <code>FromId</code> refers to the block that data is flowing from. <code>ToId</code> refers to the block the data is flowing to. <code>ToRoute</code> tells the connection which inbound route to send data to.</p>
<p>POST <code>/connections</code></p>
<p>Post a connection&#39;s JSON representation to this endpoint to create it.</p>
<p>GET <code>/connections</code></p>
<p>Lists all the current connections.</p>
<p>GET <code>/connections/{id}</code></p>
<p>Returns the JSON representation of the connection specified by <code>{id}</code>.</p>
<p>DELETE <code>/connections/{id}</code></p>
<p>Deletes the connection specified by <code>{id}</code>.</p>
<p>GET <code>/connections/{id}/{route}</code></p>
<p>Query a connection via its routes. Each connection has a <code>rate</code> route which will return an estimate of the rate of messages coming through it and a <code>last</code> route which will return the last message it saw.</p>
<h3 id='reference/command-line'>command line</h3 id='reference/command-line'>
<p>The streamtools server is completely contained in a single binary called <code>st</code>. It has a number of options:</p>
<ul>
<li><code>--port=7070</code> - specify a port number to run on. Default is 7070.</li>
<li><code>--domain=localhost</code> - if you&#39;re accessing streamtools through a URL that&#39;s not <code>localhost</code>, you need to specify it using this option.</li>
</ul>
<h2 id='more-info'>More Info</h2 id='more-info'>
<p>For more info see <a href="http://blog.nytlabs.com/2014/03/12/streamtools-a-graphical-tool-for-working-with-streams-of-data/">Introducing Streamtools</a> on The New York Times R&amp;D Labs blog.</p>
<p>For background on responsive programming tools see Bret Victor&#39;s <a href="http://worrydream.com/#!/LearnableProgramming">learnable programming</a>.</p>
<p>If you&#39;re interested in learning more about visual programming languages, check out Interface Vision&#39;s <a href="http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/">fantastic roundup dating back to 1963</a>.</p>

  </div>
</div>
</body>
</html>